-- Создадим новую БД.
-- Перед созданием новой БД необходимо подключиться к системной БД "postgres".
--
-- CREATE DATABASE test_base;

--
-- Перед выполнением остальных скриптов необходимо подключиться к БД "test_base".
--

CREATE TABLE IF NOT EXISTS test_peers (
    nickname varchar PRIMARY KEY,
    birthday date
);

CREATE TABLE IF NOT EXISTS test_tasks (
    title       varchar PRIMARY KEY,
    parent_task varchar NULL REFERENCES test_tasks (title),
    max_xp      integer
);

CREATE TABLE IF NOT EXISTS checks (
    id     bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    peer   varchar REFERENCES test_peers (nickname),
    task   varchar REFERENCES test_tasks (title),
    "date" date
);

CREATE TABLE IF NOT EXISTS xp (
    id        bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    "check"   bigint NOT NULL REFERENCES checks (id),
    xp_amount integer
);

CREATE TYPE check_status AS ENUM ('Start', 'Success', 'Failure');

CREATE TABLE IF NOT EXISTS verter (
    id      bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    "check" bigint NOT NULL REFERENCES checks (id),
    state   check_status,
    "time"  time
);

CREATE TABLE IF NOT EXISTS p2p (
    id            bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    "check"       bigint NOT NULL REFERENCES checks (id),
    checking_peer varchar REFERENCES test_peers (nickname),
    state         check_status,
    "time"        time
);

CREATE OR REPLACE FUNCTION func_get_success_tasks()
    RETURNS TABLE
            (
                Peer VARCHAR,
                Task text,
                XP   integer
            )
AS
$$
BEGIN
    RETURN QUERY SELECT tmp.peer,
                        SPLIT_PART(tmp.task, '_', 1) AS task,
                        xp.xp_amount                 AS xp
                 FROM checks AS tmp
                          JOIN xp
                               ON tmp.id = xp.check
                 ORDER BY 1, 2, 3 DESC;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION func_get_peer_was_born_in_july()
    RETURNS TABLE
            (
                Peer VARCHAR
            )
AS
$$
BEGIN
    RETURN QUERY SELECT nickname AS peer
                 FROM test_peers
                 WHERE EXTRACT(MONTH FROM birthday) = 7;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION func_validate_xp() RETURNS TRIGGER AS
$validate_xp$
BEGIN
    IF NEW.xp_amount > (SELECT max_xp
                        FROM test_tasks t
                                 INNER JOIN checks c ON t.title = c.task
                        WHERE c.id = NEW.check) THEN
        RETURN NULL;
    END IF;
    IF 0 = (SELECT COUNT(*)
            FROM checks c
                     INNER JOIN p2p p ON c.id = p."check"
                     LEFT JOIN verter v ON c.id = v."check"
            WHERE c.id = NEW.check
              AND p.state = 'Success'
              AND (v.state = 'Success' OR v.state IS NULL)) THEN
        RETURN NULL;
    END IF;
    RETURN NEW;
END;
$validate_xp$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER trg_validate_xp
    BEFORE INSERT
    ON xp
    FOR EACH ROW
EXECUTE FUNCTION func_validate_xp();

CREATE OR REPLACE PROCEDURE add_p2p_check(
    checked_peer_ varchar,
    checking_peer_ varchar,
    task_ varchar,
    status_ check_status,
    time_ time)
AS
$$
BEGIN
    IF status_ = 'Start' THEN
        INSERT INTO checks (peer, task, date)
        VALUES (checked_peer_, task_, NOW());
        INSERT INTO p2p ("check", checking_peer, state, "time")
        VALUES ((SELECT MAX(id) FROM checks),
                checking_peer_, status_, time_);
    ELSE
        INSERT INTO p2p ("check", checking_peer, state, "time")
        VALUES ((SELECT c.id
                 FROM checks c
                          INNER JOIN p2p p ON c.id = p."check"
                 WHERE c.peer = checked_peer_
                   AND c.task = task_
                 GROUP BY c.id, c.peer, c.task, c.date
                 HAVING COUNT(p.id) = 1
                 ORDER BY c.date DESC
                 LIMIT 1),
                checking_peer_, status_, time_);
    END IF;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE PROCEDURE add_verter_check(
    peer_ varchar,
    task_ varchar,
    status_ check_status,
    time_ time)
AS
$$
BEGIN
    INSERT INTO verter ("check", state, "time")
    VALUES ((SELECT c.id
             FROM checks c
                      INNER JOIN p2p p ON c.id = p."check"
             WHERE c.peer = peer_
               AND c.task = task_
               AND p.state = 'Success'
             ORDER BY c.date DESC
             LIMIT 1),
            status_, time_);
END;
$$ LANGUAGE plpgsql;

--
--1) Создать хранимую процедуру, которая, не уничтожая базу данных, уничтожает все те таблицы текущей базы данных,
-- имена которых начинаются с фразы 'TableName'.

CREATE OR REPLACE PROCEDURE drop_table_like(name varchar) AS
$$
DECLARE
    i text;
BEGIN
    FOR i IN (SELECT tablename
              FROM pg_tables
              WHERE tablename LIKE name || '%'
                AND schemaname = 'public')
        LOOP
            EXECUTE 'DROP TABLE ' || i || ' cascade;';

        END LOOP;

END;
$$ LANGUAGE plpgsql;

-- CALL drop_table_like('test');

--2) Создать хранимую процедуру с выходным параметром, которая выводит список имен и параметров
-- всех скалярных SQL функций пользователя в текущей базе данных. Имена функций без параметров не выводить.
-- Имена и список параметров должны выводиться в одну строку. Выходной параметр возвращает количество найденных функций.

CREATE OR REPLACE PROCEDURE find_scalar_functions(ref refcursor, OUT count_scalar int) AS
$$
BEGIN
    CREATE VIEW result AS
    (
    WITH tmp AS
             (SELECT routine_name,
                     ordinal_position,
                     parameter_mode,
                     parameter_name,
                     t2.data_type
              FROM (SELECT *
                    FROM information_schema.routines
                    WHERE specific_schema = ('public')
                      AND routine_type = 'FUNCTION') t1
                       JOIN
                   (SELECT *
                    FROM information_schema.parameters
                    WHERE specific_schema = ('public')
                      AND parameter_name IS NOT NULL) t2
                   ON t1.specific_name = t2.specific_name
              ORDER BY 1, 2)

    SELECT routine_name || '(' || ARRAY_TO_STRING(ARRAY_AGG(data_type), ',') ||
           ')' AS scalar_function
    FROM tmp
    GROUP BY routine_name);

    count_scalar = (SELECT COUNT(*) count_scalar
                    FROM result);

    OPEN ref FOR
        SELECT * FROM result;

    DROP VIEW result;

END;
$$ LANGUAGE plpgsql;

-- BEGIN;
-- CALL find_scalar_functions('ref', NULL);
-- FETCH ALL IN "ref";
-- CLOSE ref;
-- COMMIT;

--3) Создать хранимую процедуру с выходным параметром, которая уничтожает все SQL DML триггеры в текущей базе данных.
-- Выходной параметр возвращает количество уничтоженных триггеров.

CREATE OR REPLACE PROCEDURE drop_triggers(OUT count_dropped int) AS
$$
DECLARE
    i   text;
    tab text;
BEGIN
    SELECT COUNT(*)
    INTO count_dropped
    FROM information_schema.triggers
    WHERE (trigger_schema, event_object_schema) = ('public', 'public');

    FOR i, tab IN (SELECT trigger_name, event_object_table
                   FROM information_schema.triggers
                   WHERE (trigger_schema, event_object_schema) =
                         ('public', 'public'))
        LOOP
            EXECUTE 'DROP TRIGGER ' || i || ' ON ' || tab || ';';
        END LOOP;

END;
$$ LANGUAGE plpgsql;

-- CALL drop_triggers(NULL);

--4) Создать хранимую процедуру с входным параметром, которая выводит имена и описания типа объектов
-- (только хранимых процедур и скалярных функций), в тексте которых на языке SQL встречается строка,
-- задаваемая параметром процедуры.

CREATE OR REPLACE PROCEDURE find_routines_have_code_like(IN code varchar, ref refcursor) AS
$$
BEGIN
    OPEN ref FOR
        SELECT routine_name, routine_type
        FROM information_schema.routines
        WHERE routine_type IN ('PROCEDURE', 'FUNCTION')
          AND routine_schema = 'public'
          AND routine_definition LIKE '%' || code || '%';
END;
$$ LANGUAGE plpgsql;

-- BEGIN;
-- CALL find_routines_have_code_like('INSERT INTO', 'ref');
-- FETCH ALL IN "ref";
-- CLOSE ref;
-- COMMIT;
